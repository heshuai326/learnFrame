# JavaScript的执行上下文和执行栈
## 执行上下文的类型
执行上下文总共有三种类型
- <b>全局执行上下文：</b>只有一个，浏览器的全局对象就是window对象（node的全局对象就是glob），this指向这个全局对象
- <b>函数指向上下文：</b>存在无数个，只有在函数被调用的收才会被创建，每次调用函数都会创建一个新的执行上下文
- <b>Eval函数执行上下文：</b>指的是运行在eval函数钟的代码，很少用而且不建议使用
## 执行栈
执行栈，也叫调用栈，具有LIFO（先进后出）结构，用于存储在代码执行期间创建的所有执行上下文。<br>
首次运行JS代码时，会创建一个全局执行上下文并push到当前的执行栈中。每当发生函数调用，引擎都会为该函数创建一个新的函数执行上下文并push到当前执行栈的栈顶。<br>
根据执行栈LIFO规则，当栈顶函数运行完成受，其对应的函数执行上下文将会从执行栈中pop出来，上下文控制权将转移到当前执行栈的下一个执行上下文。
## 执行上下文的创建
执行上下文分两个阶段创建：<b>1）创建阶段；2）执行阶段</b>
### 创建阶段
- 1. 确定this的值，也被称为This Binding
- 2. LexicalEnvironment（词法环境）组件被创建
- 3. VariableEnvironment（变量环境）组件被创建
#### This Binding
- <b>全局</b>执行上下文中，this的值指向全局对象，在浏览器中this的值指向window对象，而在nodejs中指向找个文件的module对象
- <b>函数</b>执行上下文中，this的值却决于函数的调用方式。具体有：默认绑定 隐式绑定 显式绑定 new绑定 箭头函数
#### 词法环境
词法环境有两个<b>组成部分</b>
- 1. 环境记录：存储变量和函数声明的实际位置
- 2. 对外部环境的引用：可以访问其外部词法环境

词法环境有两种<b>类型</b>
- 1. 全局环境：是一个没有外部环境的词法环境，其恰不环境引用为null。拥有一个全局对象（window对象）及其关联的方法和属性（例如数组方法）以及任何用户自定义的全局变量，this的值指向找个全局对象。
- 2. 函数环境：用户在函数中定义的变量被存储在环境记录中，包含了arguments对象。对外部环境的引用可以是全局环境，可以是包含内部函数的外部函数环境。
#### 变量环境
变量环境也是一个词法环境，因此它具有上面定义的词法环境的所有属性
在ES6中，词法环境和便令环境的区别在于前者用于存储函数声明和变量（let和const）绑定，而后者仅用户存储变量（var）绑定。

<b>变量提升</b>的原因：在创建阶段，函数声明存储在环境中，而变量会被设置为underined（在var的情况下）或保持未初始化（在let和const情况下）。所以这就是为什么可以在声明之前访问var定义的变量（尽管是underined），但如果在声明之前访问let和const定义的变量就会提示引用错误的原因。这就是所谓的变量的提升。
### 执行阶段
此阶段，完整对所有变量的分配，最后执行代码
如果Javascript引擎在源代码中声明的实际位置到不到let变量的值，那么将为其分配underined值